<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Coffee Rush — v0.9.2</title>
  <meta name="description" content="Erste spielbare Version: One‑Finger Coffee‑Shop‑Spiel. Single‑File, offline‑fähig, keine Server‑Anbindung." />
  <style>
    :root{
      --bg:#221a16; --card:#2d221d; --ink:#f3e8dd; --muted:#cbbcae; --brand:#d6a879; --ok:#8fe388; --warn:#ffdb6e; --bad:#ff8ba7; --accent:#ffcf99;
      --customer-height:156px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%; touch-action:manipulation;}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: radial-gradient(1200px 800px at 70% -10%, #37291f, var(--bg) 60%); color: var(--ink);}
    .wrap{max-width:480px; margin:0 auto; padding:12px; min-height:100dvh; display:flex; flex-direction:column;}
    .wrap>header,
    .wrap>.section{flex-shrink:0;}
    .wrap>footer{margin-top:auto;}
    header{display:flex; flex-wrap:wrap; gap:6px 10px; align-items:center; justify-content:space-between; background:var(--card); border:1px solid #46372f; border-radius:14px; padding:8px 10px; position:sticky; top:0; backdrop-filter:saturate(1.2) blur(6px); z-index:10}
    header .title{font-weight:800; letter-spacing:.2px; font-size:18px; line-height:1.1}
    .stat{display:flex; gap:6px; align-items:center; font-variant-numeric:tabular-nums; flex-wrap:wrap; justify-content:flex-end; flex:1 1 auto}
    .pill{background:#3b2e27; border:1px solid #4a3a31; color:var(--ink); padding:4px 6px; border-radius:999px; font-weight:700; font-size:12px; line-height:1.1}
    .pill b{font-size:14px;}
    .lives-pill{display:flex; align-items:center; gap:6px; white-space:nowrap;}
    .lives-heart-wrap{display:flex; gap:4px; align-items:center;}
    .life-heart{font-size:16px; line-height:1; transition:transform .15s ease, opacity .15s ease; display:inline-flex; filter:drop-shadow(0 0 2px rgba(0,0,0,0.3));}
    .life-heart.lost{opacity:0.35; transform:scale(0.85); filter:none;}
    .multiplier-pill{display:flex; flex-direction:column; gap:6px; min-width:0; padding:6px 8px; align-items:stretch; flex:1 1 220px;}
    .multiplier-line{display:flex; gap:8px; align-items:baseline; font-weight:700; font-size:12px; width:100%;}
    .multiplier-value{font-size:22px; line-height:1; white-space:nowrap; font-weight:800;}
    .score-wrap{display:flex; gap:4px; align-items:baseline; margin-left:auto; min-width:0; font-size:12px; justify-content:flex-end;}
    .score-wrap-label{opacity:0.8; font-size:11px; text-transform:uppercase; letter-spacing:.3px;}
    #score{font-size:clamp(16px, 5vw, 24px); line-height:1; white-space:nowrap; font-variant-numeric:tabular-nums; text-align:right;}
    .multiplier-bar{height:4px; background:#3a2c25; border:1px solid #4a3a31; border-radius:999px; overflow:hidden; position:relative;}
    .multiplier-bar>i{display:block; height:100%; width:100%; background:linear-gradient(90deg, var(--accent), #f4c27a); transform-origin:right; transform:scaleX(0); transition:transform .12s linear;}
    .multiplier-rank{font-size:12px; color:var(--muted); font-weight:600; line-height:1.2; white-space:normal; word-break:break-word; text-wrap:balance;}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;}

    .section{background:var(--card); border:1px solid #46372f; border-radius:12px; padding:8px; margin-top:8px}

    .level-overlay{position:fixed; inset:0; background:rgba(26,18,14,0.92); display:flex; align-items:center; justify-content:center; padding:20px; z-index:999; backdrop-filter:blur(4px);}
    .level-overlay.hidden{display:none;}
    .game-over-overlay{overflow:hidden;}
    .game-over-overlay::before{content:""; position:absolute; inset:0; background-image:radial-gradient(2px 2px at 20px 40px, rgba(255,255,255,0.75), transparent), radial-gradient(1.6px 1.6px at 80px 120px, rgba(255,223,186,0.7), transparent), radial-gradient(1.8px 1.8px at 140px 60px, rgba(255,255,255,0.9), transparent); background-size:120px 120px, 180px 180px, 220px 220px; animation:twinkle 7s ease-in-out infinite; opacity:0.6; pointer-events:none;}
    .game-over-panel{position:relative; z-index:1;}
    .game-over-subtitle{margin:0 0 18px; color:var(--muted);}
    .game-over-subtitle.fired{color:var(--bad); font-weight:800; font-size:26px; text-transform:uppercase; letter-spacing:.5px; text-shadow:0 0 18px rgba(255,139,167,0.35);}
    .game-over-score{display:flex; flex-direction:column; gap:12px; margin-bottom:22px; text-align:left;}
    .score-line{display:flex; justify-content:space-between; align-items:center; gap:24px; font-size:18px;}
    .score-line span{color:var(--muted); font-weight:600; letter-spacing:.2px;}
    .score-line b{font-size:22px;}
    .score-line.title-line b{color:var(--accent); text-shadow:0 0 10px rgba(255,207,153,0.35); font-size:20px;}
    .level-panel{background:var(--card); border:1px solid #46372f; border-radius:20px; padding:26px 24px; max-width:420px; width:100%; text-align:center; box-shadow:0 18px 40px rgba(0,0,0,0.35);}
    .level-panel h1{margin:0 0 16px; font-size:26px;}
    .level-panel p{margin:0 0 22px; color:var(--muted); line-height:1.4;}
    .level-buttons{display:flex; flex-direction:column; gap:14px;}
    .level-btn{font-size:22px; padding:20px 18px; border-radius:18px;}
    .level-btn small{display:block; font-size:13px; opacity:0.85; margin-top:8px; font-weight:600; letter-spacing:.2px;}

    /* Kundenzeile */
    .row{display:flex; gap:10px; align-items:flex-start}
    .customer{flex:1; min-width:0; background:#2b201b; border:1px solid #44352d; border-radius:14px; padding:8px; position:relative; transition:transform .08s ease, box-shadow .12s ease; cursor:pointer; display:flex; flex-direction:column; overflow:hidden; min-height:var(--customer-height);}
    .customer.angry{box-shadow:0 0 0 2px #ff8ba766 inset; transform:translateY(-1px)}
    .customer.grumpy{box-shadow:0 0 0 2px #ff8ba733 inset;}
    .customer.can-serve{box-shadow:0 0 0 2px var(--accent) inset;}
    .customer.empty{border-style:dashed; border-color:#4a3a31; color:var(--muted); align-items:center; justify-content:center; text-align:center; cursor:default; pointer-events:none; min-height:var(--customer-height);}
    .customer.empty:hover{transform:none}
    .customer.empty .slot-placeholder{font-size:12px}
    .customer.cooldown{border-style:dashed; border-color:#4a3a31; color:var(--muted); align-items:center; justify-content:center; text-align:center; cursor:default; pointer-events:none; min-height:var(--customer-height);}
    .customer.waste{align-items:center; justify-content:center; gap:8px; text-align:center; padding:12px 10px; background:#2b201b; border-style:solid; border-color:#5b4034; min-height:var(--customer-height); max-height:var(--customer-height); overflow:hidden;}
    .customer.waste .waste-emoji{font-size:clamp(32px, min(12vw, 12vh), 52px); line-height:1; display:flex; align-items:center; justify-content:center; width:100%;}
    .customer.waste .waste-label{font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:center; min-height:2.4em; text-align:center; padding:0 6px;}
    .waste-progress{width:100%; height:8px; background:#3a2c25; border:1px solid #4a3a31; border-radius:999px; overflow:hidden; position:relative;}
    .waste-progress>i{display:block; height:100%; width:0; background:linear-gradient(90deg, var(--accent), #f4c27a); transition:width .12s ease;}
    .avatar{font-size:20px}
    .order{
      margin-top:6px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:6px;
      background:#3a2c25;
      border:1px solid #4a3a31;
      border-radius:12px;
      padding:6px 10px;
      font-size:clamp(12px, min(3.6vw, 3.6vh), 26px);
      line-height:1.1;
      white-space:nowrap;
      min-height:32px;
    }
    .order-name{margin-top:4px; font-size:12px; font-weight:700; text-align:center; line-height:1.15; min-height:2.6em; display:flex; align-items:center; justify-content:center; padding:0 6px; text-wrap:balance; white-space:normal; overflow-wrap:break-word; word-break:break-word; color:var(--ink);}
    .order-emoji{display:block}
    .patience{height:6px; background:#3a2c25; border:1px solid #4a3a31; border-radius:999px; overflow:hidden; margin-top:6px}
    .patience>i{display:block; height:100%; background:linear-gradient(90deg, var(--ok), #bdf59f)}
    .hearts{display:flex; gap:2px; margin-top:6px; font-size:clamp(6px, min(2.8vw, 2.8vh), 16px); line-height:1.1; flex-wrap:nowrap; align-items:center}
    .heart{transition:transform .12s ease, opacity .12s ease}
    .heart.lost{opacity:0.35; transform:scale(0.9)}
    .heart.inactive{opacity:0.15; transform:scale(0.85)}
    @keyframes twinkle {
      0% { background-position:0 0, 0 0, 0 0; opacity:0.45; }
      50% { background-position:40px 60px, -30px 50px, 25px -30px; opacity:0.9; }
      100% { background-position:0 0, 0 0, 0 0; opacity:0.45; }
    }
    @keyframes customerEnter {
      0% { transform: translateY(-120%) scale(0.95); opacity:0; }
      65% { opacity:1; }
      100% { transform: translateY(0) scale(1); opacity:1; }
    }
    @keyframes customerLeave {
      0% { transform: translateY(0) scale(1); opacity:1; }
      100% { transform: translateY(-120%) scale(0.92); opacity:0; }
    }
    .customer.incoming{animation:customerEnter .45s cubic-bezier(0.22, 1, 0.36, 1);}
    .customer.leaving{animation:customerLeave .45s cubic-bezier(0.55, 0.03, 0.65, 0.45) forwards; pointer-events:none;}
    .customer.leaving-angry{box-shadow:0 0 0 2px #ff8ba766 inset;}

    /* Tresen */
    .counter{display:grid; gap:8px; grid-template-columns:repeat(3,minmax(0,1fr))}
    .slot{min-height:128px; background:#2b201b; border:1px solid #43352d; border-radius:12px; padding:8px; position:relative; display:flex; flex-direction:column; gap:6px; cursor:pointer; transition:transform .08s ease, box-shadow .12s ease; align-items:center;}
    .slot.empty{border-style:dashed; border-color:#4a3a31; color:var(--muted); align-items:center; justify-content:center; text-align:center; font-size:12px; cursor:default}
    .slot.empty:hover{transform:none}
    .slot-placeholder{opacity:0.7; min-height:2.6em; display:flex; align-items:center; justify-content:center; padding:0 6px; text-align:center; white-space:normal; overflow-wrap:break-word; word-break:break-word;}
    .slot.ready{border-color:#6bbf59; box-shadow:0 0 0 2px #6bbf5966 inset}
    .slot.toxic{border-color:#18b56b; box-shadow:0 0 0 2px #18b56b66 inset; background:#20422f}
    .slot.brewing{opacity:.92}
    .slot.sel{outline:2px solid var(--accent);}
    .slot:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
    .slot:hover{transform:translateY(-1px)}
    .slot.empty:hover{transform:none}
    .drink-ready{display:flex; flex-direction:column; align-items:center; gap:6px; width:100%;}
    .drink-order{width:100%; justify-content:center;}
    .drink-name{font-weight:700; line-height:1.15; text-align:center; font-size:12px; margin-top:4px; min-height:2.6em; display:flex; align-items:center; justify-content:center; padding:0 6px; text-wrap:balance; white-space:normal; overflow-wrap:break-word; word-break:break-word;}
    .slot-progress{width:100%; height:6px; background:#3a2c25; border:1px solid #4a3a31; border-radius:999px; overflow:hidden; position:relative;}
    .slot-progress>i{display:block; height:100%; width:0; background:linear-gradient(90deg, var(--accent), #f4c27a); transition:width .12s ease;}
    .slot-status{font-size:12px; color:var(--muted); margin-top:4px; text-align:center; min-height:16px;}
    .btn:disabled{opacity:0.4; cursor:default; transform:none;}

    /* Auswahl & Buttons */
    .brew-bar{display:flex; gap:8px; align-items:center; margin-top:10px}
    .selection{flex:1; display:flex; gap:6px; flex-wrap:wrap; min-height:44px; align-items:center}
    .selection-empty{font-size:12px; color:var(--muted)}
    .chip{font-size:18px; background:#3a2c25; border:1px solid #4a3a31; border-radius:10px; padding:4px 8px}
    .chip-selectable{display:inline-flex; align-items:center; gap:6px; cursor:pointer; transition:background .12s ease, transform .12s ease}
    .chip-selectable:hover{background:#47372f}
    .chip-selectable:active{transform:scale(0.97)}
    .chip-selectable:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
    .btns{display:flex; gap:6px; margin-top:6px; flex-wrap:nowrap}
    .ingredient-btn{flex:1 1 0; min-width:0; padding:8px 4px; font-size:13px; border-radius:10px; line-height:1.1}
    .ingredient-label{display:block; font-size:10px; opacity:0.75; margin-top:2px}
    .btn{appearance:none; border:1px solid #5a463b; background:linear-gradient(#4b3a31,#3c2f28); color:var(--ink); padding:14px 12px; border-radius:14px; font-weight:800; font-size:18px; text-align:center; cursor:pointer; user-select:none}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn.primary{border-color:#8a6a54; background:linear-gradient(#a07756,#7e5c45);}
    .btn.primary#btnBrew{white-space:nowrap; padding:14px 16px}
    .btn.warn{border-color:#9b7b35; background:linear-gradient(#c39c4a,#9a7a3a);}
    .btn.danger{border-color:#8a3b4b; background:linear-gradient(#a05463,#7a3b46);}    

    footer{margin:14px 0; text-align:center; color:var(--muted); font-size:12px}
    .hint{font-size:12px; color:var(--muted);}
    .sel{outline:2px solid var(--accent)}

    @media (min-width: 420px) {
      header{flex-wrap:nowrap;}
      .stat{flex-wrap:nowrap;}
    }
  </style>
</head>
<body>
  <div class="level-overlay" id="levelOverlay">
    <div class="level-panel">
      <h1>Level wählen</h1>
      <p>Starte entspannt oder fordere dich selbst mit komplexeren Bestellungen heraus.</p>
      <div class="level-buttons">
        <button type="button" class="btn level-btn" data-level="1">Level 1<small>Einsteiger – einfache Bestellungen</small></button>
        <button type="button" class="btn level-btn" data-level="2">Level 2<small>Direkt mit Zwei-Zutaten-Rezepten</small></button>
        <button type="button" class="btn level-btn" data-level="3">Level 3<small>Nur Drei-Zutaten-Drinks</small></button>
      </div>
    </div>
  </div>
  <div class="level-overlay hidden game-over-overlay" id="gameOverOverlay" aria-live="polite">
    <div class="level-panel game-over-panel">
      <h1>Game Over</h1>
      <p class="game-over-subtitle fired">Du bist gefeuert!</p>
      <div class="game-over-score">
        <div class="score-line"><span>Score</span><b id="finalScore">0</b></div>
        <div class="score-line"><span>Highscore</span><b id="highScore">0</b></div>
        <div class="score-line title-line"><span>Barista-Titel</span><b id="baristaTitle">Rookie Barista</b></div>
      </div>
      <button type="button" class="btn primary" id="btnRestart">☕ Zur Levelauswahl</button>
    </div>
  </div>
  <div class="wrap">
    <header>
      <div class="title">☕ Coffee Rush</div>
      <div class="stat">
        <span class="pill multiplier-pill" aria-live="polite">
          <span class="multiplier-line">
            <span class="multiplier-value" id="multiplierValue">x1</span>
            <span class="score-wrap">
              <span class="score-wrap-label">Score</span>
              <b id="score">0</b>
            </span>
          </span>
          <span class="multiplier-bar" aria-hidden="true">
            <i id="multiplierCooldownBar"></i>
          </span>
          <span class="sr-only" id="multiplierCooldown" aria-live="polite">—</span>
          <span class="multiplier-rank" id="baristaRank">Rookie Barista</span>
        </span>
        <span class="pill lives-pill">Leben:
          <span id="lives" class="lives-heart-wrap" aria-live="polite" aria-label="Verbleibende Leben"></span>
        </span>
      </div>
    </header>

    <!-- Kundenzeile -->
    <section class="section">
      <div class="row" id="customers"></div>
    </section>

    <!-- Tresen -->
    <section class="section">
      <div class="counter" id="counter"></div>
    </section>

    <!-- Auswahl & Buttons -->
    <section class="section">
      <div class="btns" id="ingredients"></div>
      <div class="brew-bar">
        <div class="selection" id="selection"></div>
        <button id="btnBrew" class="btn primary">☕ ZUBEREITEN</button>
      </div>
    </section>

    <footer>Version <span id="versionFooter"></span> • Single‑File • Läuft komplett lokal • Touch‑optimiert</footer>
  </div>

<script>
(() => {
  // ===== Config =====
  const VERSION = 'v0.9.2';
  const MAX_CUSTOMERS = 3;
  const MAX_COUNTER_SLOTS = 3;
  const MAX_SELECTION = 3;
  const MAX_LIVES = 3;
  const HIGHSCORE_KEY = 'coffee-rush-highscore';
  const MULTIPLIER_COOLDOWN_MS = 5000;
  const BARISTA_TITLES = [
    'Rookie Barista',
    'Schaum-Schüler',
    'Latte-Künstler',
    'Espresso Virtuose',
    'Crema-Meister',
    'Bohnen-Guru',
    'Rösterei-Legende',
    'Café-Direktor',
    'Galaktischer Barista',
  ];
  const NUMBER_FORMAT = new Intl.NumberFormat('de-DE');
  const PATIENCE_SECONDS_BY_HEART = new Map([
    [5, 8],
    [4, 7],
    [3, 6],
    [2, 5],
    [1, 4],
  ]);

  const baristaTitleForScore = (score) => {
    const normalized = Math.max(0, Math.floor(Number(score) || 0));
    const index = Math.min(BARISTA_TITLES.length - 1, Math.floor(normalized / 500));
    return BARISTA_TITLES[index] || BARISTA_TITLES[0];
  };

  // 6 Zutaten-Buttons (Emoji + Key)
  const INGREDIENTS = [
    { key:'ESP', label:'☕', name:'Espresso' },
    { key:'MIL', label:'🥛', name:'Milch' },
    { key:'CHO', label:'🍫', name:'Schoko' },
    { key:'ICE', label:'🧊', name:'Eis' },
    { key:'CRM', label:'🍦', name:'Schaum' },
    { key:'SUG', label:'🧂', name:'Zucker' },
  ];

  // Rezepte: Sequenz + Brew-Time (Sekunden)
  const RECIPES = [
    { id:'espresso', name:'Espresso', seq:['ESP'], time:2 },
    { id:'double-espresso', name:'Doppelter Espresso', seq:['ESP','ESP'], time:3 },
    { id:'milk-solo', name:'Milchglas', seq:['MIL'], time:2 },
    { id:'choco-solo', name:'Schokobecher', seq:['CHO'], time:2 },
    { id:'ice-solo', name:'Eisbecher', seq:['ICE'], time:2 },
    { id:'foam-solo', name:'Milchschaum', seq:['CRM'], time:2 },
    { id:'sugar-solo', name:'Zuckerportion', seq:['SUG'], time:2 },
    { id:'sweet-espresso', name:'Süßer Espresso', seq:['ESP','SUG'], time:3 },
    { id:'flatwhite', name:'Flat White', seq:['ESP','MIL'], time:3 },
    { id:'mocha-shot', name:'Mokaccino', seq:['ESP','CHO'], time:3 },
    { id:'iced-shot', name:'Iced Shot', seq:['ESP','ICE'], time:3 },
    { id:'milk-choco', name:'Schokomilch', seq:['CHO','MIL'], time:3 },
    { id:'espresso-macchiato', name:'Espresso Macchiato', seq:['ESP','CRM'], time:3 },
    { id:'cappuccino', name:'Cappuccino', seq:['ESP','MIL','CRM'], time:4 },
    { id:'mocha', name:'Mocha', seq:['ESP','CHO','MIL'], time:5 },
    { id:'iced', name:'Iced Coffee', seq:['ESP','ICE','SUG'], time:5 },
    { id:'choco', name:'Hot Chocolate', seq:['CHO','MIL','CRM'], time:4 },
    { id:'frost-latte', name:'Iced Latte', seq:['ESP','MIL','ICE'], time:5 },
    { id:'affogato', name:'Affogato', seq:['ESP','ICE','CRM'], time:5 },
    { id:'sweet-cream', name:'Sweet Cream', seq:['MIL','CRM','SUG'], time:4 },
  ];
  const TOXIC = { id:'toxic', name:'Giftgetränk', emoji:'☠️', time:3 };
  const ingredientButtons = [];
  const view = {
    customerSlots: Array(MAX_CUSTOMERS).fill(null),
  };

  const getStoredHighscore = () => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        const saved = window.localStorage.getItem(HIGHSCORE_KEY);
        const parsed = Number.parseInt(saved || '0', 10);
        return Number.isNaN(parsed) ? 0 : Math.max(0, parsed);
      }
    } catch (err) {
      /* ignore storage errors */
    }
    return 0;
  };

  const persistHighscore = (value) => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(HIGHSCORE_KEY, String(Math.max(0, value || 0)));
      }
    } catch (err) {
      /* ignore storage errors */
    }
  };

  function ensureCustomerBox(container, index) {
    let box = view.customerSlots[index];
    if (!box) {
      box = el('div', 'customer');
      view.customerSlots[index] = box;
    }
    const currentChild = container.children[index];
    if (currentChild !== box) {
      if (box.parentElement && box.parentElement !== container) {
        box.parentElement.removeChild(box);
      }
      if (currentChild) container.insertBefore(box, currentChild);
      else container.appendChild(box);
    }
    return box;
  }

  // ===== State =====
  const state = {
    score: 0,
    mistakes: 0,
    started: false,
    level: null,
    selection: [],           // aktuelle Zutatenwahl (Keys)
    customers: Array(MAX_CUSTOMERS).fill(null),           // wartende Kunden
    counter: Array(MAX_COUNTER_SLOTS).fill(null),             // Getränke auf dem Tresen {id, name, seq, status, brewStart, readyAt, expiryAt}
    heldDrinkId: null,       // ausgewähltes fertiges Getränk zum Servieren
    totalCustomersSpawned: 0,
    lastTick: performance.now(),
    customerCooldowns: Array(MAX_CUSTOMERS).fill(0),
    customerWaste: Array(MAX_CUSTOMERS).fill(null),
    highscore: getStoredHighscore(),
    gameOver: false,
    multiplier: 1,
    multiplierCooldownUntil: 0,
  };

  function updateMultiplierDisplay(nowT = performance.now()) {
    const multiplierEl = document.getElementById('multiplierValue');
    const cooldownLabel = document.getElementById('multiplierCooldown');
    const cooldownBar = document.getElementById('multiplierCooldownBar');
    if (!multiplierEl) return;
    const currentMultiplier = Math.max(1, state.multiplier || 1);
    multiplierEl.textContent = `x${currentMultiplier}`;
    let ratio = 0;
    if (state.multiplier > 1 && state.multiplierCooldownUntil) {
      const remain = Math.max(0, state.multiplierCooldownUntil - nowT);
      ratio = Math.max(0, Math.min(1, remain / MULTIPLIER_COOLDOWN_MS));
      if (cooldownLabel) cooldownLabel.textContent = `${(remain / 1000).toFixed(1)} Sekunden Restzeit`;
    } else if (cooldownLabel) {
      cooldownLabel.textContent = 'Kein Cooldown aktiv';
    }
    if (cooldownBar) cooldownBar.style.transform = `scaleX(${ratio})`;
  }

  // ===== Utilities =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  document.title = `Coffee Rush — ${VERSION}`;
  const versionFooter = document.getElementById('versionFooter');
  if (versionFooter) versionFooter.textContent = VERSION;
  const levelOverlay = document.getElementById('levelOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const highScoreEl = document.getElementById('highScore');
  const baristaTitleEl = document.getElementById('baristaTitle');
  const restartButton = document.getElementById('btnRestart');
  document.addEventListener('dblclick', (ev) => {
    if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
      ev.preventDefault();
    }
  }, { passive: false });
  if (restartButton) {
    restartButton.addEventListener('click', () => {
      if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
      if (levelOverlay) levelOverlay.classList.remove('hidden');
    });
  }

  // ===== Audio =====
  const audio = (() => {
    const Ctor = window.AudioContext || window.webkitAudioContext;
    let ctx = null;
    const ensure = () => {
      if (!Ctor) return null;
      if (!ctx) ctx = new Ctor();
      if (ctx.state === 'suspended') ctx.resume();
      return ctx;
    };
    const presets = {
      select: [
        { freq: 420, duration: 0.08, volume: 0.09, type: 'triangle' },
      ],
      brewStart: [
        { freq: 260, duration: 0.09, volume: 0.11, type: 'sawtooth' },
        { freq: 200, duration: 0.08, volume: 0.08, type: 'triangle', gap: 0.02 },
      ],
      brewReady: [
        { freq: 640, duration: 0.1, volume: 0.14, type: 'square' },
        { freq: 880, duration: 0.16, volume: 0.12, type: 'triangle', gap: 0.02 },
      ],
      cash: [
        { freq: 520, duration: 0.09, volume: 0.16, type: 'square' },
        { freq: 820, duration: 0.12, volume: 0.14, type: 'triangle', gap: 0.02 },
        { freq: 660, duration: 0.16, volume: 0.12, type: 'square', gap: 0.04 },
      ],
      error: [
        { freq: 200, duration: 0.14, volume: 0.12, type: 'square' },
        { freq: 140, duration: 0.22, volume: 0.1, type: 'sawtooth', gap: 0.04 },
      ],
      multiplierUp: [
        { freq: 600, duration: 0.12, volume: 0.13, type: 'triangle' },
        { freq: 900, duration: 0.16, volume: 0.11, type: 'square', gap: 0.03 },
      ],
      levelStart: [
        { freq: 300, duration: 0.1, volume: 0.1, type: 'triangle' },
        { freq: 420, duration: 0.12, volume: 0.12, type: 'triangle', gap: 0.02 },
        { freq: 560, duration: 0.16, volume: 0.11, type: 'triangle', gap: 0.02 },
      ],
      customerEnter: [
        { freq: 520, duration: 0.1, volume: 0.1, type: 'triangle' },
        { freq: 380, duration: 0.12, volume: 0.08, type: 'sine', gap: 0.02 },
      ],
      cleanupTap: [
        { freq: 420, duration: 0.06, volume: 0.08, type: 'square' },
      ],
      cleanupDone: [
        { freq: 640, duration: 0.12, volume: 0.12, type: 'triangle' },
        { freq: 820, duration: 0.14, volume: 0.11, type: 'triangle', gap: 0.02 },
      ],
      gameOver: [
        { freq: 200, duration: 0.32, volume: 0.16, type: 'sawtooth' },
        { freq: 150, duration: 0.4, volume: 0.12, type: 'triangle', gap: 0.06 },
        { freq: 90, duration: 0.5, volume: 0.12, type: 'sine', gap: 0.05 },
      ],
    };
    const play = (name) => {
      const preset = presets[name];
      if (!preset || !preset.length) return;
      const context = ensure();
      if (!context) return;
      let startAt = context.currentTime;
      preset.forEach((part) => {
        const osc = context.createOscillator();
        const gain = context.createGain();
        const vol = part.volume ?? 0.1;
        gain.gain.setValueAtTime(0.0001, startAt);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, vol), startAt + 0.01);
        const endAt = startAt + (part.duration || 0.12);
        gain.gain.exponentialRampToValueAtTime(0.0001, endAt);
        osc.frequency.setValueAtTime(part.freq || 440, startAt);
        osc.type = part.type || 'sine';
        osc.connect(gain);
        gain.connect(context.destination);
        osc.start(startAt);
        osc.stop(endAt + 0.05);
        startAt = endAt + (part.gap || 0);
      });
    };
    const unlock = () => {
      const context = ensure();
      if (!context) return;
      if (context.state === 'suspended') context.resume();
    };
    const unlockEvents = ['pointerdown', 'touchstart', 'keydown'];
    unlockEvents.forEach((evt) => {
      window.addEventListener(evt, () => {
        unlock();
      }, { once: true, passive: true });
    });
    return { play };
  })();
  const backgroundMusic = (() => {
    const music = new Audio('coffee-shop-background-music.mp3');
    music.loop = true;
    music.preload = 'auto';
    music.volume = 0.35;
    let started = false;
    const tryStart = () => {
      if (started) return;
      const playPromise = music.play();
      if (playPromise && typeof playPromise.then === 'function') {
        playPromise.then(() => {
          started = true;
        }).catch(() => {});
      } else {
        started = true;
      }
    };
    const start = () => {
      tryStart();
    };
    const stop = () => {
      if (!started) return;
      music.pause();
      music.currentTime = 0;
      started = false;
    };
    const unlockEvents = ['pointerdown', 'touchstart', 'keydown'];
    unlockEvents.forEach((evt) => {
      window.addEventListener(evt, () => {
        tryStart();
      }, { once: true, passive: true });
    });
    return { start, stop };
  })();
  const el = (tag, cls, txt) => { const e = document.createElement(tag); if (cls) e.className=cls; if (txt!=null) e.textContent=txt; return e; };
  const uid = () => {
    let id = '';
    while (!id) id = Math.random().toString(36).slice(2,9);
    return id;
  };
  const randInt = (min, max) => {
    const low = Math.ceil(min);
    const high = Math.floor(max);
    return Math.floor(Math.random() * (high - low + 1)) + low;
  };
  const customerCooldownDelay = () => randInt(1000, 5000);
  const sameIngredients = (a, b) => {
    if (a.length !== b.length) return false;
    const counts = new Map();
    for (const item of a) {
      counts.set(item, (counts.get(item) || 0) + 1);
    }
    for (const item of b) {
      if (!counts.has(item)) return false;
      const next = counts.get(item) - 1;
      if (next === 0) counts.delete(item);
      else counts.set(item, next);
    }
    return counts.size === 0;
  };
  const bySeq = seq => RECIPES.find(r => sameIngredients(r.seq, seq));

  const updateHighscore = () => {
    if (state.score > state.highscore) {
      state.highscore = state.score;
      persistHighscore(state.highscore);
    }
  };

  const patienceMsForHearts = (hearts, ingredientCount = 0) => {
    const normalized = Math.max(1, Math.min(5, Math.floor(hearts || 0)));
    const baseSeconds = PATIENCE_SECONDS_BY_HEART.get(normalized) ?? (normalized + 3);
    const bonusSeconds = Math.max(0, ingredientCount);
    return (baseSeconds + bonusSeconds) * 1000;
  };

  function recipePoolForCustomer(index) {
    const level = state.level || 1;
    const maxLen = index <= 10 ? 1 : index <= 30 ? 2 : 3;
    const minLen = level === 3 ? 3 : level === 2 ? 2 : 1;
    const allowedMax = Math.max(maxLen, minLen);
    const pool = RECIPES.filter(r => r.seq.length >= minLen && r.seq.length <= allowedMax);
    if (pool.length) return pool;
    const fallback = RECIPES.filter(r => r.seq.length >= minLen);
    return fallback.length ? fallback : RECIPES;
  }

  // Patience helper
  function makeCustomer() {
    const faces = ['👩\u200d🦱','🧑\u200d🦰','🧔','👩\u200d🦳','🧑\u200d🦱','👩','🧑'];
    const index = ++state.totalCustomersSpawned;
    const pool = recipePoolForCustomer(index);
    const order = pool[Math.floor(Math.random()*pool.length)];
    const livesTotal = 3 + Math.floor(Math.random()*3); // 3..5
    const minHeartsOnArrival = Math.min(livesTotal, 3);
    const livesLeft = randInt(minHeartsOnArrival, livesTotal);
    const grumpy = livesLeft < livesTotal;
    let patience = patienceMsForHearts(livesLeft, order.seq.length);
    if (Math.random() < 0.5) {
      patience *= 2;
    }
    const createdAt = performance.now();
    const graceMs = randInt(2000, 5000);
    const countdownStart = createdAt + graceMs;
    return {
      id: uid(),
      face: faces[Math.floor(Math.random()*faces.length)],
      orderId: order.id,
      orderSeq: order.seq.slice(),
      patience,
      start: countdownStart,
      graceUntil: countdownStart,
      createdAt,
      livesTotal,
      livesLeft,
      heartsMax: 5,
      number: index,
      grumpy,
      enteringUntil: createdAt + 520,
    };
  }

  function spawnCustomers() {
    if (!state.started) return false;
    const nowT = performance.now();
    let added = false;
    for (let i = 0; i < MAX_CUSTOMERS; i++) {
      if (state.customers[i]) continue;
      if (state.customerWaste[i]) continue;
      const cooldownUntil = state.customerCooldowns[i] || 0;
      if (cooldownUntil && nowT < cooldownUntil) continue;
      const cust = makeCustomer();
      state.customers[i] = cust;
      state.customerCooldowns[i] = 0;
      added = true;
      audio.play('customerEnter');
    }
    return added;
  }

  function updateDrinkSlotVisual(slot, drink, nowT) {
    if (!slot || !drink) return;
    const fill = slot.querySelector('.slot-progress i');
    const statusLabel = slot.querySelector('.slot-status');
    if (!fill || !statusLabel) return;
    if (drink.status === 'brewing') {
      const duration = drink.brewDuration || Math.max(1, (drink.readyAt || 0) - (drink.brewStart || 0));
      const pct = duration > 0
        ? Math.max(0, Math.min(1, (nowT - (drink.brewStart || 0)) / duration))
        : 1;
      fill.style.width = (pct * 100).toFixed(1) + '%';
      fill.style.background = 'linear-gradient(90deg, var(--accent), #f4c27a)';
      statusLabel.textContent = 'Brühen …';
      slot.classList.add('brewing');
      slot.classList.remove('ready');
    } else {
      const remain = Math.max(0, (drink.expiryAt || 0) - nowT);
      const shelf = drink.shelfLife ?? ((drink.brewDuration || 0) * 3);
      const pct = shelf > 0 ? Math.max(0, Math.min(1, remain / shelf)) : 0;
      fill.style.width = (pct * 100).toFixed(1) + '%';
      const bg = pct > 0.5
        ? 'linear-gradient(90deg, var(--ok), #bdf59f)'
        : pct > 0.25
          ? 'linear-gradient(90deg, var(--warn), #ffe8a8)'
          : 'linear-gradient(90deg, var(--bad), #ffb3c3)';
      fill.style.background = bg;
      statusLabel.textContent = pct > 0 ? 'Servierbereit' : 'Verdorben';
      slot.classList.add('ready');
      slot.classList.remove('brewing');
    }
  }
  // ===== Rendering =====
  function render() {
    const scoreEl = $('#score');
    if (scoreEl) scoreEl.textContent = NUMBER_FORMAT.format(Math.max(0, state.score || 0));
    const livesEl = $('#lives');
    if (livesEl) {
      livesEl.innerHTML = '';
      const lost = Math.min(state.mistakes, MAX_LIVES);
      const remaining = Math.max(0, MAX_LIVES - lost);
      for (let i = 0; i < MAX_LIVES; i++) {
        const heart = el('span', 'life-heart', i < remaining ? '❤️' : '🤎');
        if (i >= remaining) heart.classList.add('lost');
        livesEl.append(heart);
      }
    }
    const rankEl = $('#baristaRank');
    if (rankEl) {
      const title = baristaTitleForScore(state.score);
      rankEl.textContent = title;
      rankEl.setAttribute('aria-label', `Barista-Titel: ${title}`);
      rankEl.setAttribute('title', title);
    }
    const nowRender = performance.now();
    updateMultiplierDisplay(nowRender);

    // Selection chips
    const sel = $('#selection');
    sel.innerHTML = '';
    if (state.selection.length === 0) {
      sel.append(el('div','selection-empty','Noch keine Zutaten ausgewählt'));
    } else {
      state.selection.forEach((k, idx) => {
        const ing = INGREDIENTS.find(i=>i.key===k);
        const chip = el('button','chip chip-selectable', ing ? ing.label : k);
        chip.type = 'button';
        chip.title = ing ? `Zutat entfernen: ${ing.name}` : 'Zutat entfernen';
        chip.setAttribute('aria-label', chip.title);
        chip.addEventListener('click', () => {
          state.selection.splice(idx, 1);
          render();
        });
        sel.append(chip);
      });
    }
    const limitReached = state.selection.length >= MAX_SELECTION;
    ingredientButtons.forEach(btn => {
      btn.disabled = limitReached;
      btn.setAttribute('aria-disabled', limitReached ? 'true' : 'false');
    });

    // Customers
    const cwrap = $('#customers');
    for (let i = 0; i < MAX_CUSTOMERS; i++) {
      const waste = state.customerWaste[i];
      const c = state.customers[i];
      const cooldownUntil = state.customerCooldowns[i] || 0;
      const box = ensureCustomerBox(cwrap, i);
      box.dataset.slot = String(i);
      delete box.dataset.id;
      if (waste) {
        if (box.dataset.view !== 'waste') {
          box.className = 'customer waste';
        }
        box.dataset.view = 'waste';
        box.tabIndex = 0;
        box.setAttribute('role','button');
        box.removeAttribute('aria-hidden');
        box.replaceChildren();
        const emoji = el('div','waste-emoji','💩');
        box.append(emoji);
        const label = el('div','waste-label','Aufräumen!');
        box.append(label);
        const bar = el('div','waste-progress');
        const fill = el('i');
        const pct = Math.max(0, Math.min(1, waste.clicksDone / waste.clicksRequired));
        fill.style.width = (pct * 100).toFixed(1) + '%';
        bar.append(fill);
        box.append(bar);
        continue;
      }
      if (!c) {
        const placeholderCls = (cooldownUntil && cooldownUntil > nowRender) ? 'customer cooldown' : 'customer empty';
        box.className = placeholderCls;
        box.dataset.view = 'placeholder';
        box.removeAttribute('role');
        box.setAttribute('aria-hidden','true');
        box.removeAttribute('tabindex');
        box.replaceChildren();
        const placeholderText = (cooldownUntil && cooldownUntil > nowRender)
          ? 'Neuer Kunde unterwegs …'
          : 'Freier Platz';
        box.append(el('div','slot-placeholder', placeholderText));
        continue;
      }
      const r = RECIPES.find(r=>r.id===c.orderId);
      if (box.dataset.view !== 'customer') {
        box.className = 'customer';
      }
      box.dataset.view = 'customer';
      box.tabIndex = 0;
      box.setAttribute('role','button');
      box.removeAttribute('aria-hidden');
      box.dataset.id = c.id;
      box.replaceChildren();
      if (c.grumpy) box.classList.add('grumpy');
      else box.classList.remove('grumpy');
      if (c.enteringUntil && nowRender < c.enteringUntil) {
        box.classList.add('incoming');
      } else {
        box.classList.remove('incoming');
        if (c.enteringUntil && nowRender >= c.enteringUntil) delete c.enteringUntil;
      }
      if (c.leaving) {
        box.classList.add('leaving');
        if (c.leftAngry) box.classList.add('leaving-angry');
        else box.classList.remove('leaving-angry');
      } else {
        box.classList.remove('leaving');
        box.classList.remove('leaving-angry');
      }
      const inGrace = !c.leaving && nowRender < (c.graceUntil ?? c.start);
      const avatarText = inGrace ? `${c.face} 💰` : c.face;
      const av = el('div','avatar', avatarText); box.append(av);
      const order = el('div','order');
      c.orderSeq.slice(0, 3).forEach(k=>{
        const ing = INGREDIENTS.find(i=>i.key===k);
        order.append(el('span','order-emoji', ing ? ing.label : k));
      });
      box.append(order);
      const orderName = el('div','order-name', r ? r.name : 'Getränk');
      box.append(orderName);
      const patience = el('div','patience'); const fill = el('i'); patience.append(fill); box.append(patience);
      const elapsed = Math.max(0, nowRender - c.start);
      const pct = Math.max(0, Math.min(1, 1 - elapsed / c.patience));
      fill.style.width = (pct*100).toFixed(1)+'%';
      fill.style.background = pct>0.5? 'linear-gradient(90deg, var(--ok), #bdf59f)': pct>0.25? 'linear-gradient(90deg, var(--warn), #ffe8a8)': 'linear-gradient(90deg, var(--bad), #ffb3c3)';
      if (c.angryUntil && nowRender < c.angryUntil) box.classList.add('angry');
      else box.classList.remove('angry');
      const hearts = el('div','hearts');
      const heartsMax = c.heartsMax || 5;
      const livesTotal = typeof c.livesTotal === 'number' ? c.livesTotal : heartsMax;
      const livesLeft = typeof c.livesLeft === 'number' ? c.livesLeft : livesTotal;
      for (let iH = 0; iH < heartsMax; iH++) {
        const heart = el('span','heart','❤️');
        if (iH >= livesLeft && iH < livesTotal) heart.classList.add('lost');
        if (iH >= livesTotal) heart.classList.add('inactive');
        hearts.append(heart);
      }
      box.append(hearts);
      box.classList.remove('can-serve');
      if (!c.leaving && state.heldDrinkId) {
        const held = state.counter.find(d => d && d.id === state.heldDrinkId);
        if (held && held.status === 'ready' && !held.toxic) {
          const matches = sameIngredients(held.seq, c.orderSeq);
          if (matches) box.classList.add('can-serve');
        }
      }
    }

    // Counter drinks
    const dwrap = $('#counter'); dwrap.innerHTML = '';
    const nowCounter = performance.now();
    for (let i = 0; i < MAX_COUNTER_SLOTS; i++) {
      const d = state.counter[i];
      if (!d) {
        const slot = el('div','slot empty');
        slot.append(el('div','slot-placeholder','Freier Platz'));
        dwrap.append(slot);
        continue;
      }
      const slot = el('div','slot');
      slot.tabIndex = 0;
      slot.setAttribute('role','button');
      slot.dataset.id = d.id;
      slot.classList.add(d.status);
      if (d.toxic) slot.classList.add('toxic');
      if (state.heldDrinkId === d.id) slot.classList.add('sel');
      const drink = el('div','drink-ready');
      const orderBox = el('div','order drink-order');
      d.seq.slice(0, 3).forEach(k => {
        const ing = INGREDIENTS.find(i => i.key === k);
        orderBox.append(el('span','order-emoji', ing ? ing.label : k));
      });
      if (!orderBox.childElementCount) {
        orderBox.append(el('span','order-emoji','❓'));
      }
      drink.append(orderBox);
      drink.append(el('div','drink-name', d.name));
      slot.append(drink);
      const progress = el('div','slot-progress');
      progress.append(el('i'));
      slot.append(progress);
      const status = el('div','slot-status');
      slot.append(status);
      updateDrinkSlotVisual(slot, d, nowCounter);
      dwrap.append(slot);
    }
  }

  function startGame(level) {
    const lvl = Number(level) || 1;
    const sanitized = Math.min(3, Math.max(1, lvl));
    state.level = sanitized;
    state.gameOver = false;
    state.started = true;
    state.score = 0;
    state.mistakes = 0;
    state.selection = [];
    state.customers = Array(MAX_CUSTOMERS).fill(null);
    state.counter = Array(MAX_COUNTER_SLOTS).fill(null);
    state.heldDrinkId = null;
    state.totalCustomersSpawned = 0;
    state.lastTick = performance.now();
    state.customerCooldowns = Array(MAX_CUSTOMERS).fill(0);
    state.customerWaste = Array(MAX_CUSTOMERS).fill(null);
    state.multiplier = 1;
    state.multiplierCooldownUntil = 0;
    if (levelOverlay) levelOverlay.classList.add('hidden');
    if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
    spawnCustomers();
    render();
    updateMultiplierDisplay();
    showToast(`Level ${sanitized} gestartet`);
    audio.play('levelStart');
    backgroundMusic.start();
  }

  function updateLiveElements() {
    const nowT = performance.now();
    updateMultiplierDisplay(nowT);
    $$('.customer').forEach((box) => {
      if (box.classList.contains('empty') || box.classList.contains('waste') || box.classList.contains('cooldown')) return;
      const slotIndex = Number(box.dataset.slot || '-1');
      const cust = slotIndex >= 0 ? state.customers[slotIndex] : null;
      if (!cust || cust.leaving) return;
      const fill = box.querySelector('.patience i');
      if (fill) {
        const elapsed = Math.max(0, nowT - cust.start);
        const pct = Math.max(0, Math.min(1, 1 - elapsed / cust.patience));
        fill.style.width = (pct * 100).toFixed(1) + '%';
        fill.style.background = pct>0.5? 'linear-gradient(90deg, var(--ok), #bdf59f)': pct>0.25? 'linear-gradient(90deg, var(--warn), #ffe8a8)': 'linear-gradient(90deg, var(--bad), #ffb3c3)';
      }
      const avatar = box.querySelector('.avatar');
      if (avatar) {
        const inGrace = nowT < (cust.graceUntil ?? cust.start);
        avatar.textContent = inGrace ? `${cust.face} 💰` : cust.face;
      }
      if (cust.angryUntil && nowT < cust.angryUntil) box.classList.add('angry');
      else box.classList.remove('angry');
    });
    $$('.slot').forEach((slot) => {
      if (slot.classList.contains('empty')) return;
      const did = slot.dataset.id;
      if (!did) return;
      const drink = state.counter.find((d) => d && d.id === did);
      if (!drink) return;
      updateDrinkSlotVisual(slot, drink, nowT);
    });
  }

  // ===== Toast & Interaction Helpers =====
  const toastEl = (() => {
    const toast = document.createElement('div');
    toast.id = 'toast';
    toast.style.position = 'fixed';
    toast.style.left = '50%';
    toast.style.bottom = '16px';
    toast.style.transform = 'translateX(-50%)';
    toast.style.background = '#3b2e27';
    toast.style.border = '1px solid #4a3a31';
    toast.style.padding = '8px 12px';
    toast.style.borderRadius = '10px';
    toast.style.color = 'var(--ink)';
    toast.style.fontSize = '13px';
    toast.style.opacity = '0';
    toast.style.transition = 'opacity .15s ease';
    toast.style.pointerEvents = 'none';
    toast.style.zIndex = '999';
    document.body.appendChild(toast);
    return toast;
  })();

  let toastTimer = null;
  function showToast(msg) {
    toastEl.textContent = msg;
    toastEl.style.opacity = '1';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => (toastEl.style.opacity = '0'), 1400);
  }

  const handleCounterTap = (e) => {
    if (!state.started) return;
    const slot = e.target.closest('.slot');
    if (!slot || slot.classList.contains('empty')) return;
    const id = slot.dataset.id;
    if (!id) return;
    const drink = state.counter.find((x) => x && x.id === id);
    if (!drink) return;
    if (drink.status !== 'ready') {
      showToast('Noch am Brühen …');
      return;
    }
    state.heldDrinkId = state.heldDrinkId === id ? null : id;
    render();
    audio.play('select');
  };

  const handleCustomerTap = (e) => {
    if (!state.started) return;
    const cEl = e.target.closest('.customer');
    if (!cEl) return;
    if (cEl.classList.contains('waste')) {
      const slotIndex = Number(cEl.dataset.slot || '-1');
      if (slotIndex < 0) return;
      const waste = state.customerWaste[slotIndex];
      if (!waste) return;
      waste.clicksDone = Math.min(waste.clicksRequired, waste.clicksDone + 1);
      audio.play('cleanupTap');
      if (waste.clicksDone >= waste.clicksRequired) {
        state.customerWaste[slotIndex] = null;
        state.customerCooldowns[slotIndex] = performance.now() + customerCooldownDelay();
        audio.play('cleanupDone');
      }
      render();
      return;
    }
    if (cEl.classList.contains('empty')) return;
    if (cEl.classList.contains('cooldown')) return;
    if (!state.heldDrinkId) {
      showToast('Wähle zuerst ein Getränk am Tresen');
      return;
    }
    const slotIndex = Number(cEl.dataset.slot || '-1');
    if (slotIndex < 0) return;
    const cust = state.customers[slotIndex];
    const drinkIndex = state.counter.findIndex((d) => d && d.id === state.heldDrinkId);
    const drink = drinkIndex >= 0 ? state.counter[drinkIndex] : null;
    if (!cust || !drink || cust.leaving) return;
    const want = RECIPES.find((r) => r.id === cust.orderId);
    const ok = want && !drink.toxic && sameIngredients(want.seq, drink.seq);
    if (ok) {
      const nowT = performance.now();
      const elapsed = Math.max(0, nowT - cust.start);
      const pct = Math.max(0, Math.min(1, 1 - elapsed / cust.patience));
      const baseScore = 10 + Math.round(10 * pct);
      const multiplierNow = Math.max(1, state.multiplier || 1);
      const tipActive = nowT < (cust.graceUntil ?? cust.start);
      let earnedScore = baseScore * multiplierNow;
      if (tipActive) {
        earnedScore *= 2;
      }
      state.score += earnedScore;
      updateHighscore();
      cust.leaving = true;
      cust.leaveAt = nowT + 480;
      cust.leftHappy = true;
      state.counter[drinkIndex] = null;
      state.heldDrinkId = null;
      const multiplierIncrease = tipActive ? 2 : 1;
      state.multiplier = multiplierNow + multiplierIncrease;
      state.multiplierCooldownUntil = nowT + MULTIPLIER_COOLDOWN_MS;
      audio.play('cash');
      audio.play('multiplierUp');
    } else {
      const nowT = performance.now();
      cust.angryUntil = nowT + 3000;
      const elapsed = Math.max(0, nowT - cust.start);
      const remain = Math.max(0, cust.patience - elapsed);
      const newRemain = remain * 0.4;
      cust.start = nowT - (cust.patience - newRemain);
      cust.graceUntil = cust.start;
      state.counter[drinkIndex] = null;
      state.heldDrinkId = null;
      registerMistake('Falsches Getränk!');
      if (state.gameOver) return;
    }
    render();
  };

  function setupInteractions() {
    const counterEl = $('#counter');
    const customersEl = $('#customers');
    counterEl.addEventListener('click', handleCounterTap);
    customersEl.addEventListener('click', handleCustomerTap);
  }

  // ===== Input Wiring =====
  function setupIngredients() {
    const grid = $('#ingredients');
    INGREDIENTS.forEach(ing => {
      const b = el('button','btn ingredient-btn');
      b.type = 'button';
      b.dataset.ingKey = ing.key;
      b.textContent = ing.label + ' ';
      const small = el('small','ingredient-label'); small.textContent = ing.name;
      b.append(small);
      b.addEventListener('click', () => {
        if (state.selection.length >= MAX_SELECTION) return;
        state.selection.push(ing.key);
        render();
        audio.play('select');
      });
      grid.append(b);
      ingredientButtons.push(b);
    });
  }

  // Prepare/Brew
  $('#btnBrew').addEventListener('click', () => {
    const slotIndex = state.counter.findIndex((slot) => !slot);
    if (slotIndex === -1) { bumpMistake('Tresen voll'); return; }
    if (state.selection.length === 0) { bumpMistake('Kein Rezept'); return; }
    const recipe = bySeq(state.selection);
    const id = uid();
    const nowT = performance.now();
    const brewSeconds = recipe ? recipe.time : TOXIC.time;
    const brewDuration = brewSeconds * 1000;
    const readyAt = nowT + brewDuration;
    const shelfLife = brewDuration * 3;
    const expiryAt = readyAt + shelfLife;
    const drinkData = !recipe
      ? {
          id,
          name: TOXIC.name,
          seq: state.selection.slice(),
          status: 'brewing',
          brewStart: nowT,
          readyAt,
          brewDuration,
          shelfLife,
          expiryAt,
          toxic: true,
        }
      : {
          id,
          name: recipe.name,
          seq: recipe.seq.slice(),
          status: 'brewing',
          brewStart: nowT,
          readyAt,
          brewDuration,
          shelfLife,
          expiryAt,
          toxic: false,
        };
    state.counter[slotIndex] = drinkData;
    state.selection = [];
    render();
    audio.play('brewStart');
  });

  // Select drink then tap customer to serve
  function triggerGameOver() {
    if (state.gameOver) return;
    const finalScore = state.score;
    const best = Math.max(finalScore, state.highscore || 0);
    state.highscore = best;
    persistHighscore(best);
    if (finalScoreEl) finalScoreEl.textContent = NUMBER_FORMAT.format(Math.max(0, finalScore || 0));
    if (highScoreEl) highScoreEl.textContent = NUMBER_FORMAT.format(Math.max(0, best || 0));
    if (baristaTitleEl) baristaTitleEl.textContent = baristaTitleForScore(finalScore);
    if (gameOverOverlay) gameOverOverlay.classList.remove('hidden');
    state.started = false;
    state.gameOver = true;
    state.multiplier = 1;
    state.multiplierCooldownUntil = 0;
    updateMultiplierDisplay();
    backgroundMusic.stop();
    audio.play('gameOver');
  }

  function registerMistake(message) {
    if (message) showToast(message);
    if (!state.started || state.gameOver) return;
    if (state.mistakes >= MAX_LIVES) {
      triggerGameOver();
      return;
    }
    state.mistakes += 1;
    audio.play('error');
    render();
  }

  function bumpMistake(msg) {
    registerMistake(msg);
  }

  // ===== Game Loop (timers, patience, brewing) =====
  function tick() {
    if (!state.started) {
      requestAnimationFrame(tick);
      return;
    }
    const t = performance.now();
    let needsRender = false;
    for (let i = 0; i < state.counter.length; i++) {
      const d = state.counter[i];
      if (!d) continue;
      if (d.status === 'brewing' && t >= d.readyAt) {
        d.status = 'ready';
        d.readyAt = t;
        if (typeof d.expiryAt !== 'number') d.expiryAt = t + (d.shelfLife || 0);
        needsRender = true;
        audio.play('brewReady');
      } else if (d.status === 'ready' && typeof d.expiryAt === 'number' && t >= d.expiryAt) {
        if (state.heldDrinkId === d.id) state.heldDrinkId = null;
        state.counter[i] = null;
        needsRender = true;
      }
    }
    for (let i = 0; i < state.customers.length; i++) {
      const c = state.customers[i];
      if (!c) continue;
      if (c.leaving) {
        if (!c.leaveAt) c.leaveAt = t + 420;
        if (t >= c.leaveAt) {
          const leftAngry = !!c.leftAngry;
          state.customers[i] = null;
          if (leftAngry) {
            state.customerWaste[i] = {
              clicksRequired: randInt(1, 3),
              clicksDone: 0,
            };
          } else {
            state.customerCooldowns[i] = t + customerCooldownDelay();
          }
          needsRender = true;
        }
        continue;
      }
      if (t - c.start > c.patience) {
        if (c.livesLeft && c.livesLeft > 1) {
          c.livesLeft -= 1;
          c.patience = patienceMsForHearts(c.livesLeft, c.orderSeq ? c.orderSeq.length : 0);
          c.start = t;
          c.graceUntil = c.start;
          c.angryUntil = t + 2500;
          c.grumpy = true;
          needsRender = true;
        } else {
          c.leaving = true;
          c.leftAngry = true;
          c.leaveAt = t + 420;
          c.angryUntil = t + 2500;
          c.grumpy = true;
          needsRender = true;
          registerMistake('Kunde verärgert!');
          if (state.gameOver) break;
        }
      }
    }
    if (state.multiplier > 1 && state.multiplierCooldownUntil) {
      if (t >= state.multiplierCooldownUntil) {
        state.multiplier = 1;
        state.multiplierCooldownUntil = 0;
        needsRender = true;
      }
    }
    if (state.gameOver) {
      updateLiveElements();
      requestAnimationFrame(tick);
      return;
    }
    if (spawnCustomers()) needsRender = true;
    if (needsRender) render();
    updateLiveElements();
    requestAnimationFrame(tick);
  }

  // ===== Init =====
  setupIngredients();
  setupInteractions();
  render();
  if (levelOverlay) {
    levelOverlay.querySelectorAll('[data-level]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const lvl = Number(btn.dataset.level || '1');
        startGame(Number.isNaN(lvl) ? 1 : lvl);
      });
    });
  } else {
    startGame(1);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
