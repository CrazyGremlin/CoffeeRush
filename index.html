<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Coffee Rush â€” v0.2.0</title>
  <meta name="description" content="Erste spielbare Version: Oneâ€‘Finger Coffeeâ€‘Shopâ€‘Spiel. Singleâ€‘File, offlineâ€‘fÃ¤hig, keine Serverâ€‘Anbindung." />
  <style>
    :root{
      --bg:#221a16; --card:#2d221d; --ink:#f3e8dd; --muted:#cbbcae; --brand:#d6a879; --ok:#8fe388; --warn:#ffdb6e; --bad:#ff8ba7; --accent:#ffcf99;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: radial-gradient(1200px 800px at 70% -10%, #37291f, var(--bg) 60%); color: var(--ink);}
    .wrap{max-width:480px; margin:0 auto; padding:12px;}
    header{display:flex; gap:8px; align-items:center; justify-content:space-between; background:var(--card); border:1px solid #46372f; border-radius:14px; padding:10px 12px; position:sticky; top:0; backdrop-filter:saturate(1.2) blur(6px); z-index:10}
    header .title{font-weight:800; letter-spacing:.2px}
    .stat{display:flex; gap:8px; align-items:center; font-variant-numeric:tabular-nums}
    .pill{background:#3b2e27; border:1px solid #4a3a31; color:var(--ink); padding:4px 8px; border-radius:999px; font-weight:700}

    .section{background:var(--card); border:1px solid #46372f; border-radius:16px; padding:10px; margin-top:10px}

    .level-overlay{position:fixed; inset:0; background:rgba(26,18,14,0.92); display:flex; align-items:center; justify-content:center; padding:20px; z-index:999; backdrop-filter:blur(4px);}
    .level-overlay.hidden{display:none;}
    .level-panel{background:var(--card); border:1px solid #46372f; border-radius:20px; padding:26px 24px; max-width:420px; width:100%; text-align:center; box-shadow:0 18px 40px rgba(0,0,0,0.35);}
    .level-panel h1{margin:0 0 16px; font-size:26px;}
    .level-panel p{margin:0 0 22px; color:var(--muted); line-height:1.4;}
    .level-buttons{display:flex; flex-direction:column; gap:14px;}
    .level-btn{font-size:22px; padding:20px 18px; border-radius:18px;}
    .level-btn small{display:block; font-size:13px; opacity:0.85; margin-top:8px; font-weight:600; letter-spacing:.2px;}

    /* Kundenzeile */
    .row{display:flex; gap:10px; align-items:flex-start}
    .customer{flex:1; min-width:0; background:#2b201b; border:1px solid #44352d; border-radius:14px; padding:8px; position:relative; transition:transform .08s ease, box-shadow .12s ease; cursor:pointer; display:flex; flex-direction:column}
    .customer.angry{box-shadow:0 0 0 2px #ff8ba766 inset; transform:translateY(-1px)}
    .customer.grumpy{box-shadow:0 0 0 2px #ff8ba733 inset;}
    .customer.can-serve{box-shadow:0 0 0 2px var(--accent) inset;}
    .customer.empty{border-style:dashed; border-color:#4a3a31; color:var(--muted); align-items:center; justify-content:center; text-align:center; cursor:default; pointer-events:none}
    .customer.empty:hover{transform:none}
    .customer.empty .slot-placeholder{font-size:12px}
    .avatar{font-size:20px}
    .order{
      margin-top:6px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:6px;
      background:#3a2c25;
      border:1px solid #4a3a31;
      border-radius:12px;
      padding:6px 10px;
      font-size:clamp(12px, min(3.6vw, 3.6vh), 26px);
      line-height:1.1;
      white-space:nowrap;
      min-height:32px;
    }
    .order-emoji{display:block}
    .patience{height:6px; background:#3a2c25; border:1px solid #4a3a31; border-radius:999px; overflow:hidden; margin-top:6px}
    .patience>i{display:block; height:100%; background:linear-gradient(90deg, var(--ok), #bdf59f)}
    .hearts{display:flex; gap:2px; margin-top:6px; font-size:clamp(6px, min(2.8vw, 2.8vh), 16px); line-height:1.1; flex-wrap:nowrap; align-items:center}
    .heart{transition:transform .12s ease, opacity .12s ease}
    .heart.lost{opacity:0.35; transform:scale(0.9)}
    .heart.inactive{opacity:0.15; transform:scale(0.85)}
    .bubble{position:absolute; right:8px; top:-8px; background:#3b2e27; border:1px solid #4a3a31; border-radius:999px; padding:2px 8px; font-size:12px; color:var(--muted)}

    /* Tresen */
    .counter{display:grid; gap:10px; grid-template-columns:repeat(3,minmax(0,1fr))}
    .slot{min-height:110px; background:#2b201b; border:1px solid #43352d; border-radius:14px; padding:10px; position:relative; display:flex; flex-direction:column; gap:8px; cursor:pointer; transition:transform .08s ease, box-shadow .12s ease; align-items:center;}
    .slot.empty{border-style:dashed; border-color:#4a3a31; color:var(--muted); align-items:center; justify-content:center; text-align:center; font-size:12px; cursor:default}
    .slot.empty:hover{transform:none}
    .slot-placeholder{opacity:0.7;}
    .slot.ready{border-color:#6bbf59; box-shadow:0 0 0 2px #6bbf5966 inset}
    .slot.toxic{border-color:#18b56b; box-shadow:0 0 0 2px #18b56b66 inset; background:#20422f}
    .slot.brewing{opacity:.92}
    .slot.sel{outline:2px solid var(--accent);}
    .slot:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
    .slot:hover{transform:translateY(-1px)}
    .slot.empty:hover{transform:none}
    .drink-ready{display:flex; flex-direction:column; align-items:center; gap:6px; width:100%;}
    .drink-order{width:100%; justify-content:center;}
    .drink-name{font-weight:700; line-height:1.2; text-align:center; font-size:14px; margin-top:4px;}
    .timer{position:absolute; right:10px; top:-10px; font-size:12px; background:#3b2e27; border:1px solid #4a3a31; border-radius:999px; padding:2px 8px; color:var(--muted)}

    /* Auswahl & Buttons */
    .brew-bar{display:flex; gap:10px; align-items:center; margin-top:12px}
    .selection{flex:1; display:flex; gap:6px; flex-wrap:wrap; min-height:44px; align-items:center}
    .selection-empty{font-size:12px; color:var(--muted)}
    .chip{font-size:18px; background:#3a2c25; border:1px solid #4a3a31; border-radius:10px; padding:4px 8px}
    .chip-selectable{display:inline-flex; align-items:center; gap:6px; cursor:pointer; transition:background .12s ease, transform .12s ease}
    .chip-selectable:hover{background:#47372f}
    .chip-selectable:active{transform:scale(0.97)}
    .chip-selectable:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
    .btns{display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:10px}
    .btn{appearance:none; border:1px solid #5a463b; background:linear-gradient(#4b3a31,#3c2f28); color:var(--ink); padding:14px 12px; border-radius:14px; font-weight:800; font-size:18px; text-align:center; cursor:pointer; user-select:none}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn.primary{border-color:#8a6a54; background:linear-gradient(#a07756,#7e5c45);}
    .btn.primary#btnBrew{white-space:nowrap; padding:14px 16px}
    .btn.warn{border-color:#9b7b35; background:linear-gradient(#c39c4a,#9a7a3a);}
    .btn.danger{border-color:#8a3b4b; background:linear-gradient(#a05463,#7a3b46);}    

    footer{margin:14px 0; text-align:center; color:var(--muted); font-size:12px}
    .hint{font-size:12px; color:var(--muted);}
    .sel{outline:2px solid var(--accent)}
  </style>
</head>
<body>
  <div class="level-overlay" id="levelOverlay">
    <div class="level-panel">
      <h1>Level wÃ¤hlen</h1>
      <p>Starte entspannt oder fordere dich selbst mit komplexeren Bestellungen heraus.</p>
      <div class="level-buttons">
        <button type="button" class="btn level-btn" data-level="1">Level 1<small>Einsteiger â€“ einfache Bestellungen</small></button>
        <button type="button" class="btn level-btn" data-level="2">Level 2<small>Direkt mit Zwei-Zutaten-Rezepten</small></button>
        <button type="button" class="btn level-btn" data-level="3">Level 3<small>Nur Drei-Zutaten-Drinks</small></button>
      </div>
    </div>
  </div>
  <div class="wrap">
    <header>
      <div class="title">â˜• Coffee Rush</div>
      <div class="stat">
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Fehler: <b id="mistakes">0</b></span>
      </div>
    </header>

    <!-- Kundenzeile -->
    <section class="section">
      <div class="row" id="customers"></div>
    </section>

    <!-- Tresen -->
    <section class="section">
      <div class="counter" id="counter"></div>
      <div class="hint" style="margin-top:6px">Tippe ein fertiges GetrÃ¤nk, dann den passenden Kunden.</div>
    </section>

    <!-- Auswahl & Buttons -->
    <section class="section">
      <div class="hint">Zutaten auswÃ¤hlen (Reihenfolge egal):</div>
      <div class="btns" id="ingredients"></div>
      <div class="brew-bar">
        <div class="selection" id="selection"></div>
        <button id="btnBrew" class="btn primary">â˜• ZUBEREITEN</button>
      </div>
      <div class="hint" style="margin-top:6px">Nicht jedes Rezept hat gleich viele Schritte. Falsche Kombinationen werden abgelehnt.</div>
    </section>

    <footer>Version <span id="versionFooter"></span> â€¢ Singleâ€‘File â€¢ LÃ¤uft komplett lokal â€¢ Touchâ€‘optimiert</footer>
  </div>

<script>
(() => {
  // ===== Config =====
  const VERSION = 'v0.2.0';
  const MAX_CUSTOMERS = 3;
  const MAX_COUNTER_SLOTS = 3;
  const BASE_PATIENCE = 18_000; // ms

  // 6 Zutaten-Buttons (Emoji + Key)
  const INGREDIENTS = [
    { key:'ESP', label:'â˜•', name:'Espresso' },
    { key:'MIL', label:'ðŸ¥›', name:'Milch' },
    { key:'CHO', label:'ðŸ«', name:'Schoko' },
    { key:'ICE', label:'ðŸ§Š', name:'Eis' },
    { key:'CRM', label:'ðŸ¦', name:'Schaum' },
    { key:'SUG', label:'ðŸ§‚', name:'Zucker' },
  ];

  // Rezepte: Sequenz + Brew-Time (Sekunden)
  const RECIPES = [
    { id:'espresso', name:'Espresso', seq:['ESP'], time:2 },
    { id:'milk-solo', name:'Milchglas', seq:['MIL'], time:2 },
    { id:'choco-solo', name:'Schokobecher', seq:['CHO'], time:2 },
    { id:'ice-solo', name:'Eisbecher', seq:['ICE'], time:2 },
    { id:'foam-solo', name:'Milchschaum', seq:['CRM'], time:2 },
    { id:'sugar-solo', name:'Zuckerportion', seq:['SUG'], time:2 },
    { id:'sweet-espresso', name:'SÃ¼ÃŸer Espresso', seq:['ESP','SUG'], time:3 },
    { id:'flatwhite', name:'Flat White', seq:['ESP','MIL'], time:3 },
    { id:'mocha-shot', name:'Mokaccino', seq:['ESP','CHO'], time:3 },
    { id:'iced-shot', name:'Iced Shot', seq:['ESP','ICE'], time:3 },
    { id:'milk-choco', name:'Schokomilch', seq:['CHO','MIL'], time:3 },
    { id:'cappuccino', name:'Cappuccino', seq:['ESP','MIL','CRM'], time:4 },
    { id:'latte', name:'Latte Macchiato', seq:['MIL','ESP','CRM'], time:4 },
    { id:'mocha', name:'Mocha', seq:['ESP','CHO','MIL'], time:5 },
    { id:'iced', name:'Iced Coffee', seq:['ESP','ICE','SUG'], time:5 },
    { id:'choco', name:'Hot Chocolate', seq:['CHO','MIL','CRM'], time:4 },
  ];
  const TOXIC = { id:'toxic', name:'GiftgetrÃ¤nk', emoji:'â˜ ï¸', time:3 };

  // ===== State =====
  const state = {
    score: 0,
    mistakes: 0,
    started: false,
    level: null,
    selection: [],           // aktuelle Zutatenwahl (Keys)
    customers: Array(MAX_CUSTOMERS).fill(null),           // wartende Kunden
    counter: Array(MAX_COUNTER_SLOTS).fill(null),             // GetrÃ¤nke auf dem Tresen {id, name, seq, readyAt, status}
    heldDrinkId: null,       // ausgewÃ¤hltes fertiges GetrÃ¤nk zum Servieren
    totalCustomersSpawned: 0,
    lastTick: performance.now(),
  };

  // ===== Utilities =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  document.title = `Coffee Rush â€” ${VERSION}`;
  const versionFooter = document.getElementById('versionFooter');
  if (versionFooter) versionFooter.textContent = VERSION;
  const levelOverlay = document.getElementById('levelOverlay');
  const el = (tag, cls, txt) => { const e = document.createElement(tag); if (cls) e.className=cls; if (txt!=null) e.textContent=txt; return e; };
  const uid = () => {
    let id = '';
    while (!id) id = Math.random().toString(36).slice(2,9);
    return id;
  };
  const sameIngredients = (a, b) => {
    if (a.length !== b.length) return false;
    const counts = new Map();
    for (const item of a) {
      counts.set(item, (counts.get(item) || 0) + 1);
    }
    for (const item of b) {
      if (!counts.has(item)) return false;
      const next = counts.get(item) - 1;
      if (next === 0) counts.delete(item);
      else counts.set(item, next);
    }
    return counts.size === 0;
  };
  const bySeq = seq => RECIPES.find(r => sameIngredients(r.seq, seq));

  function recipePoolForCustomer(index) {
    const level = state.level || 1;
    const maxLen = index <= 10 ? 1 : index <= 30 ? 2 : 3;
    const minLen = level === 3 ? 3 : level === 2 ? 2 : 1;
    const allowedMax = Math.max(maxLen, minLen);
    const pool = RECIPES.filter(r => r.seq.length >= minLen && r.seq.length <= allowedMax);
    if (pool.length) return pool;
    const fallback = RECIPES.filter(r => r.seq.length >= minLen);
    return fallback.length ? fallback : RECIPES;
  }

  // Patience helper
  function makeCustomer() {
    const faces = ['ðŸ‘©\u200dðŸ¦±','ðŸ§‘\u200dðŸ¦°','ðŸ§”','ðŸ‘©\u200dðŸ¦³','ðŸ§‘\u200dðŸ¦±','ðŸ‘©','ðŸ§‘'];
    const index = ++state.totalCustomersSpawned;
    const pool = recipePoolForCustomer(index);
    const order = pool[Math.floor(Math.random()*pool.length)];
    let patience = BASE_PATIENCE * (0.85 + Math.random()*0.5);
    const livesTotal = 3 + Math.floor(Math.random()*3); // 3..5
    let livesLeft = livesTotal;
    let grumpy = false;
    if (livesTotal === 3) {
      livesLeft = 1; // schon 2 Leben verloren
      patience *= 0.85;
      grumpy = true;
    }
    return {
      id: uid(),
      face: faces[Math.floor(Math.random()*faces.length)],
      orderId: order.id,
      orderSeq: order.seq.slice(),
      patience,
      start: performance.now(),
      livesTotal,
      livesLeft,
      heartsMax: 5,
      number: index,
      grumpy,
    };
  }

  function spawnCustomers() {
    if (!state.started) return false;
    let added = false;
    for (let i = 0; i < MAX_CUSTOMERS; i++) {
      if (!state.customers[i]) {
        state.customers[i] = makeCustomer();
        added = true;
      }
    }
    return added;
  }
  // ===== Rendering =====
  function render() {
    $('#score').textContent = state.score;
    $('#mistakes').textContent = state.mistakes;

    // Selection chips
    const sel = $('#selection');
    sel.innerHTML = '';
    if (state.selection.length === 0) {
      sel.append(el('div','selection-empty','Noch keine Zutaten ausgewÃ¤hlt'));
    } else {
      state.selection.forEach((k, idx) => {
        const ing = INGREDIENTS.find(i=>i.key===k);
        const chip = el('button','chip chip-selectable', ing ? ing.label : k);
        chip.type = 'button';
        chip.title = ing ? `Zutat entfernen: ${ing.name}` : 'Zutat entfernen';
        chip.setAttribute('aria-label', chip.title);
        chip.addEventListener('click', () => {
          state.selection.splice(idx, 1);
          render();
        });
        sel.append(chip);
      });
    }

    // Customers
    const cwrap = $('#customers'); cwrap.innerHTML = '';
    for (let i = 0; i < MAX_CUSTOMERS; i++) {
      const c = state.customers[i];
      if (!c) {
        const placeholder = el('div','customer empty');
        placeholder.append(el('div','slot-placeholder','Freier Platz'));
        placeholder.setAttribute('aria-hidden','true');
        cwrap.append(placeholder);
        continue;
      }
      const r = RECIPES.find(r=>r.id===c.orderId);
      const box = el('div','customer'); box.tabIndex = 0;
      box.setAttribute('role','button');
      if (c.grumpy) box.classList.add('grumpy');
      const av = el('div','avatar', c.face); box.append(av);
      const bub = el('div','bubble', r ? r.name : 'Bestellung'); box.append(bub);
      const order = el('div','order');
      c.orderSeq.slice(0, 3).forEach(k=>{
        const ing = INGREDIENTS.find(i=>i.key===k);
        order.append(el('span','order-emoji', ing ? ing.label : k));
      });
      box.append(order);
      const patience = el('div','patience'); const fill = el('i'); patience.append(fill); box.append(patience);
      // Patience percent
      const elapsed = performance.now() - c.start; const pct = Math.max(0, 1 - elapsed / c.patience);
      fill.style.width = (pct*100).toFixed(1)+'%';
      fill.style.background = pct>0.5? 'linear-gradient(90deg, var(--ok), #bdf59f)': pct>0.25? 'linear-gradient(90deg, var(--warn), #ffe8a8)': 'linear-gradient(90deg, var(--bad), #ffb3c3)';
      if (c.angryUntil && performance.now() < c.angryUntil) box.classList.add('angry');
      const hearts = el('div','hearts');
      const heartsMax = c.heartsMax || 5;
      const livesTotal = typeof c.livesTotal === 'number' ? c.livesTotal : heartsMax;
      const livesLeft = typeof c.livesLeft === 'number' ? c.livesLeft : livesTotal;
      for (let iH = 0; iH < heartsMax; iH++) {
        const heart = el('span','heart','â¤ï¸');
        if (iH >= livesLeft && iH < livesTotal) heart.classList.add('lost');
        if (iH >= livesTotal) heart.classList.add('inactive');
        hearts.append(heart);
      }
      box.append(hearts);
      if (state.heldDrinkId) {
        const held = state.counter.find(d => d && d.id === state.heldDrinkId);
        if (held && held.status === 'ready' && !held.toxic) {
          const matches = sameIngredients(held.seq, c.orderSeq);
          if (matches) box.classList.add('can-serve');
        }
      }
      box.dataset.id = c.id;
      cwrap.append(box);
    }

    // Counter drinks
    const dwrap = $('#counter'); dwrap.innerHTML = '';
    for (let i = 0; i < MAX_COUNTER_SLOTS; i++) {
      const d = state.counter[i];
      if (!d) {
        const slot = el('div','slot empty');
        slot.append(el('div','slot-placeholder','Freier Platz'));
        dwrap.append(slot);
        continue;
      }
      const slot = el('div','slot');
      slot.tabIndex = 0;
      slot.setAttribute('role','button');
      slot.dataset.id = d.id;
      slot.classList.add(d.status);
      if (d.toxic) slot.classList.add('toxic');
      if (state.heldDrinkId === d.id) slot.classList.add('sel');
      const drink = el('div','drink-ready');
      const orderBox = el('div','order drink-order');
      d.seq.slice(0, 3).forEach(k => {
        const ing = INGREDIENTS.find(i => i.key === k);
        orderBox.append(el('span','order-emoji', ing ? ing.label : k));
      });
      if (!orderBox.childElementCount) {
        orderBox.append(el('span','order-emoji','â“'));
      }
      drink.append(orderBox);
      drink.append(el('div','drink-name', d.name));
      slot.append(drink);
      const left = d.status==='brewing'? Math.max(0, Math.ceil((d.readyAt - performance.now())/1000)) : 0;
      const timer = el('div','timer', d.status==='brewing'? (left+'s') : 'Bereit');
      slot.append(timer);
      dwrap.append(slot);
    }
  }

  function startGame(level) {
    const lvl = Number(level) || 1;
    const sanitized = Math.min(3, Math.max(1, lvl));
    state.level = sanitized;
    state.started = true;
    state.score = 0;
    state.mistakes = 0;
    state.selection = [];
    state.customers = Array(MAX_CUSTOMERS).fill(null);
    state.counter = Array(MAX_COUNTER_SLOTS).fill(null);
    state.heldDrinkId = null;
    state.totalCustomersSpawned = 0;
    state.lastTick = performance.now();
    if (levelOverlay) levelOverlay.classList.add('hidden');
    spawnCustomers();
    render();
    showToast(`Level ${sanitized} gestartet`);
  }

  function updateLiveElements() {
    const nowT = performance.now();
    $$('.customer').forEach((box) => {
      if (box.classList.contains('empty')) return;
      const cid = box.dataset.id;
      if (!cid) return;
      const cust = state.customers.find((c) => c && c.id === cid);
      if (!cust) return;
      const fill = box.querySelector('.patience i');
      if (fill) {
        const pct = Math.max(0, 1 - (nowT - cust.start) / cust.patience);
        fill.style.width = (pct * 100).toFixed(1) + '%';
        fill.style.background = pct>0.5? 'linear-gradient(90deg, var(--ok), #bdf59f)': pct>0.25? 'linear-gradient(90deg, var(--warn), #ffe8a8)': 'linear-gradient(90deg, var(--bad), #ffb3c3)';
      }
      if (cust.angryUntil && nowT < cust.angryUntil) box.classList.add('angry');
      else box.classList.remove('angry');
    });
    $$('.slot').forEach((slot) => {
      const timer = slot.querySelector('.timer');
      const did = slot.dataset.id;
      if (!timer || !did) return;
      const drink = state.counter.find((d) => d && d.id === did);
      if (!drink) return;
      if (drink.status === 'brewing') {
        const left = Math.max(0, Math.ceil((drink.readyAt - nowT)/1000));
        timer.textContent = left + 's';
        slot.classList.add('brewing');
        slot.classList.remove('ready');
      } else {
        timer.textContent = 'Bereit';
        slot.classList.add('ready');
        slot.classList.remove('brewing');
      }
    });
  }

  // ===== Toast & Interaction Helpers =====
  const toastEl = (() => {
    const toast = document.createElement('div');
    toast.id = 'toast';
    toast.style.position = 'fixed';
    toast.style.left = '50%';
    toast.style.bottom = '16px';
    toast.style.transform = 'translateX(-50%)';
    toast.style.background = '#3b2e27';
    toast.style.border = '1px solid #4a3a31';
    toast.style.padding = '8px 12px';
    toast.style.borderRadius = '10px';
    toast.style.color = 'var(--ink)';
    toast.style.fontSize = '13px';
    toast.style.opacity = '0';
    toast.style.transition = 'opacity .15s ease';
    toast.style.pointerEvents = 'none';
    toast.style.zIndex = '999';
    document.body.appendChild(toast);
    return toast;
  })();

  let toastTimer = null;
  function showToast(msg) {
    toastEl.textContent = msg;
    toastEl.style.opacity = '1';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => (toastEl.style.opacity = '0'), 1400);
  }

  const handleCounterTap = (e) => {
    if (!state.started) return;
    const slot = e.target.closest('.slot');
    if (!slot || slot.classList.contains('empty')) return;
    const id = slot.dataset.id;
    if (!id) return;
    const drink = state.counter.find((x) => x && x.id === id);
    if (!drink) return;
    if (drink.status !== 'ready') {
      showToast('Noch am BrÃ¼hen â€¦');
      return;
    }
    state.heldDrinkId = state.heldDrinkId === id ? null : id;
    render();
  };

  const handleCustomerTap = (e) => {
    if (!state.started) return;
    const cEl = e.target.closest('.customer');
    if (!cEl) return;
    if (cEl.classList.contains('empty')) return;
    if (!state.heldDrinkId) {
      showToast('WÃ¤hle zuerst ein GetrÃ¤nk am Tresen');
      return;
    }
    const cid = cEl.dataset.id;
    const custIndex = state.customers.findIndex((c) => c && c.id === cid);
    const cust = custIndex >= 0 ? state.customers[custIndex] : null;
    const drinkIndex = state.counter.findIndex((d) => d && d.id === state.heldDrinkId);
    const drink = drinkIndex >= 0 ? state.counter[drinkIndex] : null;
    if (!cust || !drink) return;
    const want = RECIPES.find((r) => r.id === cust.orderId);
    const ok = want && !drink.toxic && sameIngredients(want.seq, drink.seq);
    if (ok) {
      state.score += 10;
      const elapsed = performance.now() - cust.start;
      const pct = Math.max(0, 1 - elapsed / cust.patience);
      state.score += Math.round(10 * pct);
      state.customers[custIndex] = null;
      state.counter[drinkIndex] = null;
      state.heldDrinkId = null;
      spawnCustomers();
    } else {
      const nowT = performance.now();
      cust.angryUntil = nowT + 3000;
      const elapsed = nowT - cust.start;
      const remain = Math.max(0, cust.patience - elapsed);
      const newRemain = remain * 0.4;
      cust.start = nowT - (cust.patience - newRemain);
      state.mistakes += 1;
      state.counter[drinkIndex] = null;
      state.heldDrinkId = null;
      showToast('Falsches GetrÃ¤nk!');
    }
    render();
  };

  function setupInteractions() {
    const counterEl = $('#counter');
    const customersEl = $('#customers');
    counterEl.addEventListener('click', handleCounterTap);
    customersEl.addEventListener('click', handleCustomerTap);
  }

  // ===== Input Wiring =====
  function setupIngredients() {
    const grid = $('#ingredients');
    INGREDIENTS.forEach(ing => {
      const b = el('button','btn');
      b.textContent = ing.label + ' ';
      const small = el('small'); small.textContent = ing.name; small.style.display='block'; small.style.fontSize='12px'; small.style.opacity='0.8';
      b.append(small);
      b.addEventListener('click', () => { state.selection.push(ing.key); render(); });
      grid.append(b);
    });
  }

  // Prepare/Brew
  $('#btnBrew').addEventListener('click', () => {
    const slotIndex = state.counter.findIndex((slot) => !slot);
    if (slotIndex === -1) { bumpMistake('Tresen voll'); return; }
    if (state.selection.length === 0) { bumpMistake('Kein Rezept'); return; }
    const recipe = bySeq(state.selection);
    const id = uid();
    const nowT = performance.now();
    const drinkData = !recipe
      ? { id, name: TOXIC.name, seq: state.selection.slice(), status:'brewing', readyAt: nowT + TOXIC.time*1000, toxic:true }
      : { id, name: recipe.name, seq: recipe.seq.slice(), status:'brewing', readyAt: nowT + recipe.time*1000, toxic:false };
    state.counter[slotIndex] = drinkData;
    state.selection = [];
    render();
  });

  // Select drink then tap customer to serve
  function bumpMistake(_msg) {
    state.mistakes += 1;
    if (_msg) showToast(_msg);
  }

  // ===== Game Loop (timers, patience, brewing) =====
  function tick() {
    if (!state.started) {
      requestAnimationFrame(tick);
      return;
    }
    const t = performance.now();
    let needsRender = false;
    state.counter.forEach((d) => {
      if (!d) return;
      if (d.status === 'brewing' && t >= d.readyAt) {
        d.status = 'ready';
        needsRender = true;
      }
    });
    for (let i = state.customers.length - 1; i >= 0; i--) {
      const c = state.customers[i];
      if (!c) continue;
      if (t - c.start > c.patience) {
        if (c.livesLeft && c.livesLeft > 1) {
          c.livesLeft -= 1;
          c.start = t;
          c.angryUntil = t + 2500;
          c.grumpy = true;
          needsRender = true;
        } else {
          state.customers[i] = null;
          state.mistakes += 1;
          needsRender = true;
        }
      }
    }
    if (spawnCustomers()) needsRender = true;
    if (needsRender) render();
    updateLiveElements();
    requestAnimationFrame(tick);
  }

  // ===== Init =====
  setupIngredients();
  setupInteractions();
  render();
  if (levelOverlay) {
    levelOverlay.querySelectorAll('[data-level]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const lvl = Number(btn.dataset.level || '1');
        startGame(Number.isNaN(lvl) ? 1 : lvl);
      });
    });
  } else {
    startGame(1);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
